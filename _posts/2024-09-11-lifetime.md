---
layout: post
title: C++ 生命周期与内存对齐与小缓冲区优化（不严谨版）
header-img: img/tree4.JPG
header-style: text
catalog: true
tags:
  - C++
  - 生命周期
  - 内存对齐
  - 小缓冲区优化
---

![village2](/img/tree4.JPG)

本文还未完成。
{:.error}

由于 C++ 生命周期相关的概念非常复杂且一直处于不完善持续更新的阶段，本文只是为了博客之后的话题而尽量简单且无法保证完全严谨地介绍一下相关知识。
{:.warning}

## 0. 对象大小与对齐

对于任何一个类型都存在 size 和 alignment 两个属性，其中对齐是非常重要却容易被新手忽视的属性。

以常见的 64 位平台举例：

```cpp
static_assert(sizeof(char) == 1);
static_assert(sizeof(int) == 4);
static_assert(sizeof(long long) == 8);
static_assert(sizeof(long double) == 16);

static_assert(alignof(char) == 1);
static_assert(alignof(int) == 4);
static_assert(alignof(long long) == 8);
static_assert(alignof(long double) == 16);
```

其中 long double 对应的 16 字节为最大的基础对齐，malloc 返回的指针默认要求必须为最大基础对齐。

所以对齐简单来说就是一个对象所在的地址应该是 2^n 的整数倍，比如以 8 字节对齐那么它的地址低三位就一定是 0。这样的好处在于 cpu 从内存中可以更高效地取得数据。如果对象所在位置不满足对齐，会导致效率低甚至程序崩溃。

所以一个结构体如果摆放成员变量比较乱，就会出现很多 padding 损失：

```cpp
struct Test {
    char a;
    int b;
    long long c;
    long double d;
    char e;
};
```

本例中 Test 的对齐会与类中最大的对齐持平，即 16 字节，那它的地址低 4 位就是 0。

假设它的地址为 010000，那 char a 的对齐要求是 1，可以摆在 010000；int b 的起始地址从 010001 算起，但是它的对齐为 4，则只能到 010100；之后 long long c 的起始地址从 011000 算起，已经满足对齐 8 的要求；long double d 的起始地址从 100000 算起，依旧没问题；最后 char e 则位于 110000。

最后 Test 会占到 110001，但是由于对齐 padding 实际最后会占到 1000000。

但是尾 padding 实际上可以被利用：

```cpp
// Derived can reuse Base's back padding.
struct Base {
    alignas(8) unsigned char buf[1]{};
};

struct Derived : Base {
    int i{};
};

static_assert(sizeof(Base)    == 8, "");
static_assert(sizeof(Derived) == 8, "");
```

这里 Base 的 size 为 1 而 alignment 为 8，只能多了 7 字节 padding，继承时 Derived 中的 int 重复利用了 padding 的空间。但是这也存在风险，之后空基类优化的文章会说。

注意到这里用 alignas(N) 可以将对象对齐扩展到任意 2^n，可以超过 16 字节的基础最大对齐。这带来了一个新的问题。

之前提到的 malloc 分配的指针为最大基础对齐。所以即使是为了 char 分配内存而连续调用 malloc(1)，返回的地址也会相差 16 字节，这显然会造成资源浪费。

```cpp
std::cout << std::malloc(1) << '\n' << std::malloc(1);
/* Output:
0x63f8053bb2b0
0x63f8053bc2e0
*/
```

而如果是用 alignas(N) 拓展的过对其类型，malloc 压根不能满足这种需求。如果是一些向量计算库为了过对齐一般需要自己实现内存分配。到了 C++17 开始标准库才引入了 aligned_malloc 和重载了对齐的 :operator new。

还有就是，由于内存对齐导致指针低位一般都为 0，而这些位可以用来存放一些标志位，被广泛地用于标准库的实现。比如 std::string 需要 1 bit 来区分当前是否为小字符串，谁也不想为了 1 bit 用一个 bool 最后还因为跟其它成员变量对其而浪费 8 字节。还有红黑树也需要 1 bit 来辨认红黑结点，不过我没见过对此的优化，大家都选择了浪费 8 字节。

## 1. 开篇

生命周期是 C++ 标准用来描述相关规定的一个抽象机概念，并不代表真实执行的指令里需要有对应的存在。但它又确实非常必要，因为编译器需要逻辑自洽的标准来决定哪些操作能被允许而哪些可以视为非法，从而进行一些更好的优化。

但是大部分公认的操作，虽然在 C++20 和 C++23 才开始进入标准，但是长久以来作为 ub 也一直是被编译器支持且绝对安全的。

一个对象的生命周期大概可以认为有这五个阶段：分配存储空间，构造或初始化，使用，析构，释放存储空间。

同时，对象必然是下列四种存储期类型之一：静态存储期，线程存储期，自动存储期，动态存储期。除了动态存储期都有着差不多的格式，规则则有细微差别：

```cpp
void f() {
    int a = 1;
    const b = 2;
    static c = 3;
    static thread_local d = 4;
}
```

自动存储期变量在声明行分配存储与构造，在离开块作用域时析构与释放存储。

静态存储器变量在第一次运行至所在行时构造，且生命一直持续到程序结束。

线程存储期变量在每个线程分别运行至所在行时构造出独属于当前线程的一份对象，且生命一直持续到线程结束。

动态存储期则为：

```cpp
int* p = new int{1};
/* 等价于：
void* __p = ::operator new(sizeof(int)); // 分配存储
__try {
    ::new(__p) int{1}; // 构造
} __catch (...) {
    ::operator delete(__p); // 构造时抛出异常则构造失败，直接释放存储
    __throw;
}
int* p = static_cast<int*>(__p);
*/

delete p;
/* 等价于：
using T = int;
p->~T(); // 析构
::operator delete(p); // 释放存储
*/
```

所以不管是 int a = 1; 还是 int* b = new int{1}; 都是一样的逻辑，对于前者其实依旧可以手动析构并在原位构造新对象：

```cpp
void f() {
    int a = 1;
    using T = int;
    a.~T();
    ::new(&a) int{2};
    std::cout << a; // 2
}
```

甚至对于类的赋值：

```cpp
Test& operator=(const Test& other) {
    this->~Test();
    ::new(this) Test{other};
    return *this;
}
```

不过这种操作可能存在风险，相关知识可见：[std::launder - cppreference.com](https://zh.cppreference.com/w/cpp/utility/launder)

## 2. 小缓冲区优化
